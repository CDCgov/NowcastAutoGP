var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"This page provides documentation for all exported functions and types in NowcastAutoGP.jl.","category":"section"},{"location":"api/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"api/#API","page":"API Reference","title":"API","text":"","category":"section"},{"location":"api/#NowcastAutoGP.TData","page":"API Reference","title":"NowcastAutoGP.TData","text":"TData{D, F}\n\nA container for transformed time series data used in nowcasting models.\n\nType Parameters\n\nD: Type for dates/timestamps (e.g., Date, DateTime)\nF: Type for numeric values, automatically promoted from input types\n\nFields\n\nds::Vector{D}: Vector of dates or timestamps corresponding to observations\ny::Vector{F}: Vector of transformed target values (result of applying transformation)\nvalues::Vector{F}: Vector of original values, converted to common type with y\n\nConstructor\n\nTData(ds, values; transformation)\n\nCreate a TData instance by applying a transformation to the input values.\n\nArguments\n\nds: Vector of dates or timestamps\nvalues: Vector of original numeric values\ntransformation: Function to apply element-wise to values to create y\n\nThe constructor automatically promotes types using promote_type to ensure y and values have compatible numeric types.\n\nExample\n\nusing Dates\n\ndates = [Date(2023, 1, 1), Date(2023, 1, 2), Date(2023, 1, 3)]\nraw_values = [10, 20, 30]\n\n# Apply log transformation\ntdata = TData(dates, raw_values; transformation = log)\n\n# Apply custom transformation\ntdata = TData(dates, raw_values; transformation = x -> (x - mean(raw_values)) / std(raw_values))\n\nValidation\n\nThe constructor ensures that ds and values have the same length and throws an ArgumentError if they don't match.\n\n\n\n\n\n","category":"type"},{"location":"api/#NowcastAutoGP._get_offset-Union{Tuple{Vector{F}}, Tuple{F}} where F<:AbstractFloat","page":"API Reference","title":"NowcastAutoGP._get_offset","text":"_get_offset(values::Vector{F}) where {F <: Real}\n\nInternal function to compute an offset for transformations to ensure numerical stability.\n\n\n\n\n\n","category":"method"},{"location":"api/#NowcastAutoGP._inv_boxcox-Union{Tuple{F}, Tuple{Real, Any, F}} where F","page":"API Reference","title":"NowcastAutoGP._inv_boxcox","text":"_inv_boxcox(λ::Real, offset::F, max_values) where {F}\n\nInternal function to compute the inverse Box-Cox transformation with edge case handling.\n\n\n\n\n\n","category":"method"},{"location":"api/#NowcastAutoGP._with_single_blas-Tuple{Any}","page":"API Reference","title":"NowcastAutoGP._with_single_blas","text":"Temporarily set BLAS threads to 1 to avoid deadlock with AutoGP's internal Threads.@threads.\n\n\n\n\n\n","category":"method"},{"location":"api/#NowcastAutoGP.create_nowcast_data-Tuple{AbstractMatrix, Vector{Dates.Date}}","page":"API Reference","title":"NowcastAutoGP.create_nowcast_data","text":"create_nowcast_data(nowcasts::AbstractMatrix, dates::Vector{Date}; transformation = y -> y)\n\nCreate nowcast data structures from a matrix of nowcast scenarios.\n\nArguments\n\nnowcasts: A matrix where each column represents one nowcast scenario. The number of rows must match the length of dates.\ndates: A vector of Date objects corresponding to the nowcast time points.\ntransformation: A function to apply to the nowcast values (default: identity).\n\nReturns\n\nA vector of NamedTuples, where each NamedTuple represents one nowcast scenario with fields:\n\nds: The dates vector\ny: The transformed nowcast values\nvalues: The original (untransformed) nowcast values\n\nNotes\n\nThis method converts the matrix to a vector of columns internally and delegates to the vector method.\n\nExample\n\n# Matrix with 3 time points (rows) and 2 scenarios (columns)\nnowcasts = [10.5 9.8; 11.2 10.9; 12.1 11.5]\ndates = [Date(2024,1,1), Date(2024,1,2), Date(2024,1,3)]\nnowcast_data = create_nowcast_data(nowcasts, dates; transformation = log)\n# Returns vector of 2 NamedTuples, each with transformed and original values\n\n\n\n\n\n","category":"method"},{"location":"api/#NowcastAutoGP.create_nowcast_data-Tuple{AbstractVector, Vector{Dates.Date}}","page":"API Reference","title":"NowcastAutoGP.create_nowcast_data","text":"create_nowcast_data(nowcasts::AbstractVector, dates::Vector{Date}; transformation = y -> y)\n\nCreate nowcast data structures from a vector of nowcast scenarios.\n\nArguments\n\nnowcasts: A vector where each element is a vector of nowcast values representing one scenario. All inner vectors must have the same length as dates.\ndates: A vector of Date objects corresponding to the nowcast time points.\ntransformation: A function to apply to the nowcast values (default: identity).\n\nReturns\n\nA vector of NamedTuples, where each NamedTuple represents one nowcast scenario with fields:\n\nds: The dates vector\ny: The transformed nowcast values\nvalues: The original (untransformed) nowcast values\n\nExample\n\n# Two nowcast scenarios for 3 dates\nnowcasts = [[10.5, 11.2, 12.1], [9.8, 10.9, 11.5]]\ndates = [Date(2024,1,1), Date(2024,1,2), Date(2024,1,3)]\nnowcast_data = create_nowcast_data(nowcasts, dates; transformation = log)\n# Returns vector of 2 NamedTuples, each with transformed and original values\n\n\n\n\n\n","category":"method"},{"location":"api/#NowcastAutoGP.create_transformed_data-Tuple{Any, Any}","page":"API Reference","title":"NowcastAutoGP.create_transformed_data","text":"create_transformed_data(ds, values; transformation)\n\nConvenience function to create a TData instance from any iterable inputs of dates/times and values.\n\n\n\n\n\n","category":"method"},{"location":"api/#NowcastAutoGP.forecast-Tuple{GPModel, Any, Int64}","page":"API Reference","title":"NowcastAutoGP.forecast","text":"forecast(model, forecast_dates, forecast_draws::Int)\n\nGenerate forecast samples from a fitted AutoGP model.\n\nArguments\n\nmodel: Fitted AutoGP.GPModel.\nforecast_dates: Vector or range of dates to predict.\nforecast_draws: Number of samples to draw.\n\nKeyword arguments\n\ninv_transformation: Function applied elementwise to map forecasts back to the original scale (default: identity).\nforecast_n_hmc: If nothing, draw from the current model state. If an Int, run that many HMC parameter steps before each draw (default: nothing).\n\nReturns\n\nA matrix of samples with size (length(forecast_dates), forecast_draws).\n\n\n\n\n\n","category":"method"},{"location":"api/#NowcastAutoGP.forecast_with_nowcasts-Tuple{GPModel, AbstractVector{<:TData}, Any, Int64}","page":"API Reference","title":"NowcastAutoGP.forecast_with_nowcasts","text":"forecast_with_nowcasts(base_model, nowcasts, forecast_dates, forecast_draws_per_nowcast;\n                      inv_transformation = y -> y, n_mcmc = 0, n_hmc = 0, ess_threshold = 0.0)\n\nGenerate forecasts by conditioning on multiple nowcast scenarios.\n\nArguments\n\nbase_model: Fitted AutoGP.GPModel trained on confirmed (non-nowcast) data.\nnowcasts: Vector of TData scenarios with fields ds, y, and values.\nforecast_dates: Vector or range of dates to predict.\nforecast_draws_per_nowcast: Samples per scenario.\n\nKeyword arguments\n\ninv_transformation: Function applied elementwise to map forecasts back to the original scale (default: identity).\nn_mcmc: Number of MCMC structure steps after adding each nowcast (default: 0). If > 0, n_hmc must also be > 0.\nn_hmc: Number of HMC parameter steps per MCMC step (default: 0). Can be > 0 even if n_mcmc == 0.\ness_threshold: Effective sample size threshold for particle resampling, as a fraction of total particles (default: 0.0).\nforecast_n_hmc: Number of HMC steps to run before each forecast draw (default: nothing). If nothing, no HMC steps are taken during forecasting.\nverbose: If true, display progress information during forecasting (default: false).\n\nReturns\n\nA matrix with size (length(forecast_dates), length(nowcasts) * forecast_draws_per_nowcast).\n\nNotes\n\nEach scenario operates on an independent copy of the base model, so the original model is never mutated.\nn_mcmc == 0 && n_hmc > 0 performs parameter-only updates to the particle ensemble; n_mcmc > 0 && n_hmc > 0 performs full MCMC.\nforecast_n_hmc is independent of n_mcmc and n_hmc and controls HMC steps only during forecasting, not during nowcast incorporation.\n\nIf n_mcmc == 0 && n_hmc == 0 && forecast_n_hmc > 0, HMC steps are only taken during forecasting, not during nowcast incorporation.\n\nExample\n\nnowcast_scenarios = [\n    (ds = [Date(2024,1,1), Date(2024,1,2)], y = [10.5, 11.2], values = [10.5, 11.2]),\n    (ds = [Date(2024,1,1), Date(2024,1,2)], y = [9.8, 10.9], values = [9.8, 10.9]),\n]\nforecast_dates = Date(2024,1,1):Day(1):Date(2024,1,10)\nforecasts = forecast_with_nowcasts(base_model, nowcast_scenarios, forecast_dates, 100)\n\n\n\n\n\n","category":"method"},{"location":"api/#NowcastAutoGP.get_transformations-Union{Tuple{F}, Tuple{String, Vector{F}}} where F<:Real","page":"API Reference","title":"NowcastAutoGP.get_transformations","text":"get_transformations(transform_name::String, values::Vector{F}) where {F <: Real}\n\nReturn a tuple of transformation and inverse transformation functions for the specified transformation type.\n\nThis function creates appropriate data transformations for Gaussian Process modeling, where the goal is to transform the input data to make it more suitable for modeling (typically more Gaussian-like) and then provide the inverse transformation to convert predictions back to the original scale.\n\nArguments\n\ntransform_name::String: The name of the transformation to apply. Supported values:\n\"percentage\": For data bounded between 0 and 100 (e.g., percentages, rates)\n\"positive\": For strictly positive data (uses log transformation)\n\"boxcox\": Applies Box-Cox transformation with automatically fitted λ parameter\nvalues::Vector{F}: The input data values used to fit transformation parameters and determine offset\n\nReturns\n\nA tuple (forward_transform, inverse_transform) where:\n\nforward_transform: Function that transforms data from original scale to transformed scale\ninverse_transform: Function that transforms data from transformed scale back to original scale\n\nTransformation Details\n\nPercentage Transformation\n\nUse case: Data bounded between 0 and 100 (percentages, rates)\nForward: y ↦ logit((y + offset) / 100)\nInverse: y ↦ max(logistic(y) * 100 - offset, 0)\nNote: Uses logit/logistic to map [0,100] to (-∞,∞) and back\n\nPositive Transformation\n\nUse case: Strictly positive continuous data\nForward: y ↦ log(y + offset)\nInverse: y ↦ max(exp(y) - offset, 0)\nNote: Log transformation for positive data with offset for numerical stability\n\nBox-Cox Transformation\n\nUse case: General purpose transformation for positive data\nForward: y ↦ BoxCox_λ(y + offset) where λ is automatically fitted\nInverse: Custom inverse function handling edge cases for numerical stability\nNote: Automatically determines optimal λ parameter via maximum likelihood\n\nOffset Calculation\n\nAn offset is automatically calculated using _get_offet(values):\n\nIf minimum value is 0: offset = (minimum positive value) / 2\nOtherwise: offset = 0\nPurpose: Ensures numerical stability and handles boundary cases\n\nExamples\n\n# Percentage data (0-100 range)\nvalues = [10.5, 25.3, 67.8, 89.2]\nforward, inverse = get_transformations(\"percentage\", values)\ntransformed = forward.(values)\nrecovered = inverse.(transformed)\n\n# Strictly positive data\nvalues = [1.2, 3.4, 8.9, 15.6]\nforward, inverse = get_transformations(\"positive\", values)\n\n# General positive data with automatic Box-Cox fitting\nvalues = [0.1, 0.5, 2.3, 5.7, 12.1]\nforward, inverse = get_transformations(\"boxcox\", values)\n\nThrows\n\nAssertionError: If transform_name is not one of the supported transformation types\nAssertionError: Via _get_offet if values is empty or contains negative values\n\nSee Also\n\n_get_offset: Calculates the offset value for numerical stability\n_inv_boxcox: Handles inverse Box-Cox transformation with edge case handling\n\n\n\n\n\n","category":"method"},{"location":"api/#NowcastAutoGP.make_and_fit_model-Tuple{TData}","page":"API Reference","title":"NowcastAutoGP.make_and_fit_model","text":"make_and_fit_model(data; n_particles=8, smc_data_proportion=0.1, n_mcmc=200, n_hmc=50, kwargs...)\n\nCreate and fit a Gaussian Process (GP) model using Sequential Monte Carlo (SMC) sampling.\n\nArguments\n\ndata: A data structure containing the dataset (data.ds) and the target values (data.y).\nn_particles: The number of particles to use in the SMC sampling (default: 8).\nsmc_data_proportion: The proportion of the data to use in each SMC step (default: 0.1).\nn_mcmc: The number of MCMC samples (default: 200).\nn_hmc: The number of HMC samples (default: 50).\nkwargs...: Additional keyword arguments to pass to the AutoGP.fit_smc! function.\n\nReturns\n\nmodel: The fitted GP model.\n\n\n\n\n\n","category":"method"},{"location":"vignettes/getting-started/","page":"Getting Started","title":"Getting Started","text":"using Markdown","category":"section"},{"location":"vignettes/getting-started/#Getting-Started-with-NowcastAutoGP","page":"Getting Started","title":"Getting Started with NowcastAutoGP","text":"Combining nowcasting and AutoGP\n\nCDC Center for Forecasting and Outbreak Analytics (CFA/CDC)","category":"section"},{"location":"vignettes/getting-started/#Introduction","page":"Getting Started","title":"Introduction","text":"This tutorial demonstrates how to use NowcastAutoGP for epidemiological forecasting - making forecasts of future disease activity despite reporting delays making the latest data unreliable. This is a common challenge in public health surveillance where case reports arrive with delays. In this tutorial, we will want to forecast future weekly hospital admissions with confirmed Covid diagnosis despite uncertainty around the eventual value of recent admissions. The reason for the uncertainty is that despite eventually having a record of severe cases arriving in a given week (we call this the reference date), at any given reporting week (we call this the report date) recent reference dates will not have complete data.","category":"section"},{"location":"vignettes/getting-started/#What-is-AutoGP?","page":"Getting Started","title":"What is AutoGP?","text":"AutoGP.jl is a Julia package for automatic Gaussian process model discovery. Rather than fitting a single GP with a fixed kernel, AutoGP maintains an ensemble of GP models (called particles), each with a different kernel structure (e.g. periodic, linear, radial basis, or compositions thereof). AutoGP combines three inference techniques:\n\nSequential Monte Carlo (SMC) steps as new data is ingested, which resample the particle ensemble of GP models to focus on promising kernel structures.   New data can be provided to SMC either in batches (AutoGP has built-in support for scheduling data ingestion in batches) or incrementally (e.g. for nowcasting).\nMarkov chain Monte Carlo (MCMC) steps that propose new kernel structures for each particle, allowing the ensemble to explore a rich space of possible kernels.\nHamiltonian Monte Carlo (HMC) steps that tune the continuous hyperparameters of each particle's kernel, improving fit and increasing diversity.\n\nThe result is a weighted mixture of GPs that captures uncertainty over both kernel structure and hyperparameters, aiming to avoid manual kernel engineering.\n\nThe main limitation of AutoGP is that it is specialised for pure time series modelling (e.g. no covariates).","category":"section"},{"location":"vignettes/getting-started/#What-is-Nowcasting-and-how-does-NowcastAutoGP-help?","page":"Getting Started","title":"What is Nowcasting and how does NowcastAutoGP help?","text":"The time series Gaussian process structure discovery and ensemble forecast package AutoGP.jl is highly impressive, but doesn't include features for ingesting the kind of data we expect from a signal that needs significant nowcasting to become reliable.\n\nNowcastAutoGP is an extension of AutoGP that uses AutoGP's incremental inference features to include nowcasting results into the forecasting problem.","category":"section"},{"location":"vignettes/getting-started/#The-forecasting-problem-with-data-revisions","page":"Getting Started","title":"The forecasting problem with data revisions","text":"When forecasting a time series with revisions, we consider two time indices:\n\nThe reference date t which is the date of the event we are trying to forecast (e.g. hospital admission).\nThe report date T which is the \"current date\" of a group of data indexed by reference dates; this represents how the data looked at different points in time as more data came in and revisions were made.\n\nOn any given report date T, we have a time series of data for reference dates and past report dates up to T:\n\n(X_tT)_t=1 ldots T T = 1 2 ldots T\n\nThe core forecasting challenge is to forecast the eventual time series, that is the time series of eventual values for each reference date:\n\nX_t = X_tinfty qquad t = 1 2 ldots\n\nwhere \"T = infty\" represents the eventual reported value of the time series at some point in the future when the data is fully revised and stable.","category":"section"},{"location":"vignettes/getting-started/#Nowcasting-to-address-data-revisions","page":"Getting Started","title":"Nowcasting to address data revisions","text":"On any report date T we can split the latest available data on a backwards horizon D where we consider older data \"confirmed\"\n\ntextConfirmed by  T  (X_tT)_t=1 ldots T-D = (X_t)_t=1 ldots T-D\n\nWe don't expect any further revision to this data set. The rest of the latest available data we consider \"unconfirmed\"\n\ntextUnconfirmed by  T  (X_tT)_t=T-D+1 ldots T\n\nwhere we expect potentially significant future revisions.\n\nSuppose, we have a nowcasting model f_nc that generates k = 1 ldots K samples nowcasting the eventual time series over the uncertain data period, conditioned on all the data including for past report dates:\n\n(X^(k)_t)_t=T-D+1 ldots T sim f_nc mid (X_tT)_t=1 ldots T T = 1 2 ldots T\n\nfor example by sampling from the posterior distribution of the nowcast model. We can use the nowcast samples to \"repair\" the data for the uncertain period and then make forecasts conditioning on the repaired data, which should lead to better forecasts than conditioning on the latest reported data alone.","category":"section"},{"location":"vignettes/getting-started/#Batching-over-nowcast-samples-for-forecasting","page":"Getting Started","title":"Batching over nowcast samples for forecasting","text":"A \"naive\" forecast distribution made on report date T which treats the latest data as ground truth:\n\nmathbbPleft( (X_t)_t= T+1 ldots T+h mid (X_tT)_t=1 ldots T right)\n\ncould be biased because it doesn't account for the fact that the latest data is likely to be revised upwards.\n\nHowever, using the nowcast estimates for the uncertain data we can instead make forecasts by marginalizing over the nowcast samples conditioning on the all data:\n\nmathbbP((X_t)_t= T+1 ldots T+h mid (X_tT)_t=1 ldots T T = 1 2 ldots T ) = frac1K sum_k mathbbP((X_t)_t= T+1 ldots T+h  (X_t)_t=1 ldots T-D (X^(k)_t)_t=T-D+1 ldots T)\n\nThis kind of forecasting is particularly convenient for AutoGP because of the underlying use of data batched SMC inference, which allows us to use the standard end-to-end inference for the confirmed data and then batch over the sampled nowcasts using incremental inference. Also, note that this approach is agnostic to the nowcasting model used, so more sophisticated nowcasting approaches could be used to generate the nowcast samples.","category":"section"},{"location":"vignettes/getting-started/#Methodology-overview","page":"Getting Started","title":"Methodology overview","text":"The main functions we offer for inference and forecasting are:\n\nNowcastAutoGP.make_and_fit_model: This wraps AutoGP functionality to make inference on the stable part of the time series data using sequential Monte Carlo (SMC) over sequences of data ingestion with n_particle SMC particles. Each particle represents a Gaussian process (GP) model for the time series, and at each data ingestion step this particle ensemble can be resampled. Within each SMC particle new possible GP kernel structures and hyperparmeter values are proposed using a specialised MCMC proposal distribution for structural choices (see AutoGP overview for details) and HMC for continuous parameter samples.\nNowcastAutoGP.forecast_with_nowcasts: This batches over proposed nowcasts for recent data, incrementally adding nowcast possible data to make forecasts. The forecast distribution is the batch of forecasts over nowcasts of recent data.","category":"section"},{"location":"vignettes/getting-started/#Using-NowcastAutoGP-with-NHSN-hospitalisation-data","page":"Getting Started","title":"Using NowcastAutoGP with NHSN hospitalisation data","text":"","category":"section"},{"location":"vignettes/getting-started/#Loading-dependencies","page":"Getting Started","title":"Loading dependencies","text":"using NowcastAutoGP\nusing CairoMakie\nusing Dates, Distributions, Random\nusing CSV, TidierData\nusing Parameters: @unpack\n\nRandom.seed!(123)\nCairoMakie.activate!(type = \"png\")","category":"section"},{"location":"vignettes/getting-started/#Loading-Surveillance-Data","page":"Getting Started","title":"Loading Surveillance Data","text":"We are going to demonstrate using NowcastAutoGP for forecasting the CDC's National Healthcare Safety Network (NHSN) reported Covid hospitalisations. We stored a vintaged data set locally.\n\ndatapath = joinpath(\n    pkgdir(NowcastAutoGP), \"docs\", \"vignettes\", \"data\", \"vintaged_us_nhsn_data.csv\"\n)\nnhsn_vintage_covid_data = CSV.read(datapath, DataFrame)\n\nunique_dates = sort(unique(nhsn_vintage_covid_data.reference_date)) # Add time_index column for plotting (1 = minimum date, 2 = next date, etc.)\nd2index(d) = (d - minimum(unique_dates)).value\n\nnhsn_vintage_covid_data = @mutate(\n    nhsn_vintage_covid_data,\n    time_index = d2index(reference_date)\n)\n@glimpse(nhsn_vintage_covid_data)\n\nRows: 4102\nColumns: 8\n.reference_dateDates.Date     2022-10-01, 2022-10-01, 2022-10-01, 2022-10-01, 20\n.report_date   Dates.Date     2025-02-01, 2025-02-08, 2025-02-15, 2025-02-22, 20\n.confirm       Float64        26180.0, 26180.0, 26180.0, 26180.0, 26180.0, 26180\n.max_confirm   Float64        26150.0, 26150.0, 26150.0, 26150.0, 26150.0, 26150\n.lag           Int64          854, 861, 868, 875, 882, 889, 896, 903, 910, 917,\n.multiplier    Float64        0.9988540870893812, 0.9988540870893812, 0.99885408\n.geo_value     InlineStrings.String3us, us, us, us, us, us, us, us, us, us, us,\n.time_index    Int64          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\n\nWe see that the most recent report date, especially, is often revised upward eventually.\n\nunique_report_dates = sort(unique(nhsn_vintage_covid_data.report_date))\n# Select every 4th report date, but always include the latest one\nselected_dates = unique_report_dates[1:4:end]\nif unique_report_dates[end] ∉ selected_dates\n    selected_dates = vcat(selected_dates, unique_report_dates[end])\nend\nn_dates = length(selected_dates)\n\n# Create figure\nfig = Figure(size = (800, 600))\nax = Axis(\n    fig[1, 1],\n    xlabel = \"Reference Date\",\n    ylabel = \"NHSN confirmed Covid hospitalisations\",\n    title = \"Reference Date vs Confirm by Report Date (Oct 2024+, all US)\"\n)\n\n# Generate colors - latest date will be black\ncolors = [i == n_dates ? :black : Makie.wong_colors()[mod1(i, 7)] for i in 1:n_dates]\n\n# Plot each selected report date using time_index\nfor (report_date, color) in zip(selected_dates, colors)\n    date_data = @chain nhsn_vintage_covid_data begin\n        @filter(report_date == !!report_date)\n        @arrange(reference_date)\n    end\n\n    scatterlines!(\n        ax, date_data.time_index, date_data.confirm,\n        color = color,\n        label = string(report_date),\n        markersize = 8,\n        linewidth = 2\n    )\nend\n\n# Set up custom x-axis with date strings\nplot_start_date = Date(2024, 10, 1)\nplot_end_date = Date(2025, 10, 1)\n\n# Create tick positions and labels (show every 4 weeks ≈ monthly)\ntick_dates = range(plot_start_date, step = Week(4), length = 13)\ntick_indices = d2index.(tick_dates)\ntick_labels = [monthname(d)[1:3] * \"-\" * string(d)[(end - 1):end] for d in tick_dates]\n\nax.xticks = (tick_indices, tick_labels)\n\n# Add legend\naxislegend(ax, \"report dates\"; position = :rt)\nxlims!(ax, d2index(plot_start_date), d2index(plot_end_date))\nylims!(ax, 0, 2.2e4)\nresize_to_layout!(fig)\nfig\n\n(Image: )","category":"section"},{"location":"vignettes/getting-started/#Training-data","page":"Getting Started","title":"Training data","text":"We know that some recent periods have had bad reporting for NHSN, so we exclude them from the training data.\n\nexclusion_periods = [\n    (Date(2024, 5, 1), Date(2024, 6, 1)),\n    (Date(2024, 10, 1), Date(2024, 11, 15)),\n]\n\ntraining_data = let\n    function in_any_period(d)\n        in_periods = [d >= period[1] && d <= period[2] for period in exclusion_periods]\n        return ~any(in_periods)\n    end\n\n    @chain nhsn_vintage_covid_data begin\n        @filter(in_any_period(reference_date))\n    end\nend\n@glimpse(training_data)\n\nRows: 3772\nColumns: 8\n.reference_dateDates.Date     2022-10-01, 2022-10-01, 2022-10-01, 2022-10-01, 20\n.report_date   Dates.Date     2025-02-01, 2025-02-08, 2025-02-15, 2025-02-22, 20\n.confirm       Float64        26180.0, 26180.0, 26180.0, 26180.0, 26180.0, 26180\n.max_confirm   Float64        26150.0, 26150.0, 26150.0, 26150.0, 26150.0, 26150\n.lag           Int64          854, 861, 868, 875, 882, 889, 896, 903, 910, 917,\n.multiplier    Float64        0.9988540870893812, 0.9988540870893812, 0.99885408\n.geo_value     InlineStrings.String3us, us, us, us, us, us, us, us, us, us, us,\n.time_index    Int64          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n","category":"section"},{"location":"vignettes/getting-started/#Utility-functions","page":"Getting Started","title":"Utility functions","text":"We add two utility functions to this tutorial that wrap some NowcastAutoGP capabilities:\n\nA fit_on_data function that does the core workflow on confirmed data:\n\nTransforms the time series into the unconstrained domain. We use an optimized Box-Cox transform to \"normalize\" the data.\nRedact some of the recent data, either for poor quality or in preparation for nowcasting.\nPasses to the make_and_fit_model function from NowcastAutoGP.\n\nfunction fit_on_data(\n        report_date;\n        n_redact,\n        max_ahead = 8,\n        training_data = training_data,\n        n_particles = 24, # number of SMC particles, i.e. GP models, to maintain in the ensemble\n        smc_data_proportion = 0.1, # proportion of data to ingest per SMC step, by default shuffled batches\n        n_mcmc = 50, n_hmc = 50 # number of MCMC and HMC steps to run after each SMC step for particle refinement/refresh\n    )\n\n    # Filter for correct report date\n    date_data = @chain training_data begin\n        @filter(report_date == !!report_date)\n        @arrange(reference_date)\n    end\n\n    # Dates to forecast\n    forecast_dates = [maximum(date_data.reference_date) + Week(k) for k in 0:max_ahead]\n\n    transformation, inv_transformation = get_transformations(\"boxcox\", date_data.confirm)\n    data_to_fit = create_transformed_data(\n        date_data.reference_date[1:(end - n_redact)],\n        date_data.confirm[1:(end - n_redact)]; transformation\n    )\n    data_to_revise = (\n        revise_dates = date_data.reference_date[(end - n_redact + 1):end],\n        revise_values = date_data.confirm[(end - n_redact + 1):end],\n    )\n    model = make_and_fit_model(\n        data_to_fit;\n        n_particles,\n        smc_data_proportion,\n        n_mcmc, n_hmc\n    )\n    return model, forecast_dates, transformation, inv_transformation, data_to_revise\nend\n\nWe also give a handy plotting utility for plotting our results.\n\nfunction plot_with_forecasts(\n        forecasts, title::String;\n        n_ahead,\n        selected_dates,\n        colors = colors,\n        covid_data = nhsn_vintage_covid_data,\n        plot_start_date = plot_start_date,\n        plot_end_date = plot_end_date,\n        y_lim_up = 2.2e4,\n        size = (1000, 700),\n        xticks = (tick_indices, tick_labels)\n    )\n    fig = Figure(size = size)\n    ax = Axis(\n        fig[1, 1],\n        xlabel = \"Date\",\n        ylabel = \"NHSN confirmed Covid hospitalizations\",\n        title = title\n    )\n\n    # Plot forecasts\n    for (report_date, forecast, color) in zip(selected_dates, forecasts, colors)\n        date_data = @chain nhsn_vintage_covid_data begin\n            @filter(report_date == !!report_date)\n            @arrange(reference_date)\n        end\n\n        # Plot historical data as light lines\n        scatterlines!(\n            ax, date_data.time_index, date_data.confirm,\n            color = color,\n            linewidth = 2,\n            label = \"$(report_date) data\"\n        )\n\n        # Extract quantiles for forecasts\n        q25 = forecast.iqrs[1:n_ahead, 1]\n        median = forecast.iqrs[1:n_ahead, 2]\n        q75 = forecast.iqrs[1:n_ahead, 3]\n        forecast_indices = d2index.(forecast.dates)[1:n_ahead]\n\n        # Plot uncertainty band (25%-75%)\n        band!(\n            ax, forecast_indices, q25, q75,\n            color = (color, 0.3)\n        )\n\n        # Plot median forecast\n        lines!(\n            ax, forecast_indices, median,\n            color = color,\n            linewidth = 3,\n            linestyle = :dash\n        )\n    end\n\n    # Add legend\n    axislegend(ax, \"report dates\"; position = :rt)\n    xlims!(ax, d2index(plot_start_date), d2index(plot_end_date))\n    ylims!(ax, 0, y_lim_up)\n    ax.xticks = xticks\n    resize_to_layout!(fig)\n    return fig\nend","category":"section"},{"location":"vignettes/getting-started/#Fitting-models-on-different-report-dates","page":"Getting Started","title":"Fitting models on different report dates","text":"Most of the nowcasting revision happens in the most recent week, so as a first step we will fit models on different report dates redacting each most recent week. These fitted models represent an AutoGP fit to the \"confirmed\" data on each report date. In the next section we will use these fits to make forecasts with different nowcasting approaches.\n\nfitted_models_by_report_date = map(selected_dates) do report_date\n    model, forecast_dates,\n        transformation,\n        inv_transformation,\n        data_to_revise = fit_on_data(\n        report_date;\n        n_redact = 1,\n        training_data = training_data,\n        n_particles = 4\n    )\n    return (\n        model_dict = Dict(model), forecast_dates = forecast_dates,\n        transformation = transformation, inv_transformation = inv_transformation,\n        data_to_revise = data_to_revise,\n    )\nend\n\n[ Info: Using Box-Cox transformation with λ = 0.22131240688077408 and offset = 0.0\n[ Info: Using Box-Cox transformation with λ = 0.20417626199072905 and offset = 0.0\n[ Info: Using Box-Cox transformation with λ = 0.16610573403843354 and offset = 0.0\n[ Info: Using Box-Cox transformation with λ = 0.121124688924113 and offset = 0.0\n[ Info: Using Box-Cox transformation with λ = 0.11522816443710317 and offset = 0.0\n[ Info: Using Box-Cox transformation with λ = 0.12383606867895428 and offset = 0.0\n[ Info: Using Box-Cox transformation with λ = 0.09504558934153737 and offset = 0.0\n[ Info: Using Box-Cox transformation with λ = 0.04783408834285875 and offset = 0.0\n[ Info: Using Box-Cox transformation with λ = 0.04071498264851919 and offset = 0.0\n","category":"section"},{"location":"vignettes/getting-started/#Forecasting","page":"Getting Started","title":"Forecasting","text":"In this section we will use the fitted models to make forecasts of future confirmed hospitalisations. We will compare four approaches:\n\nForecasting naively.\nRemoving uncertain data.\nForecasting with a simple nowcast without refreshing the particles with HMC.\nForecasting with a simple nowcast with HMC refreshing between nowcast draws.\nForecasting with a simple nowcast with HMC refreshing between forecast draws.","category":"section"},{"location":"vignettes/getting-started/#Approach-1:-Forecasting-naively","page":"Getting Started","title":"Approach 1: Forecasting naively","text":"Naively, we could just use the latest reported data without considering revisions. This approach is equivalent to creating the \"nowcast\" by taking the latest reported data as the best estimate of the eventual data, which is a common mistake when using data with reporting delays. This will be biased because we know that typically the most recent data will be revised upwards, but represents a common error when using this data stream.\n\nn_forecasts = 2000\nnaive_forecasts_by_reference_date = map(fitted_models_by_report_date) do fitted_model\n    @unpack model_dict, forecast_dates, transformation, inv_transformation,\n        data_to_revise = fitted_model\n    model = GPModel(model_dict)\n    # Create a \"naive\" nowcast by taking the latest reported data as the best estimate of the eventual data\n    # NB: we wrap the single nowcast in a vector to be compatible with the nowcast input \"vector of vectors\" format\n    naive_nowcasts = create_nowcast_data(\n        [data_to_revise.revise_values], data_to_revise.revise_dates;\n        transformation = transformation\n    )\n\n    forecasts = forecast_with_nowcasts(\n        model, naive_nowcasts, forecast_dates, n_forecasts;\n        inv_transformation = inv_transformation, ess_threshold = 1.0\n    )\n\n    iqr_forecasts = mapreduce(vcat, eachrow(forecasts)) do fc\n        qs = quantile(fc, [0.25, 0.5, 0.75])\n        qs'\n    end\n\n    return (dates = forecast_dates, forecasts = forecasts, iqrs = iqr_forecasts)\nend\n\nWhen we plot we see that the unrevised data consistently underestimates the eventual counts, which leads to poor forecasting.\n\nplot_with_forecasts(\n    naive_forecasts_by_reference_date, \"Forecasts from Different Report Dates (naive)\";\n    n_ahead = 4,\n    selected_dates = selected_dates\n)\n\n(Image: )","category":"section"},{"location":"vignettes/getting-started/#Approach-2:-Removing-uncertain-data","page":"Getting Started","title":"Approach 2: Removing uncertain data","text":"We note that the problem is mainly with the most recent week of hospitalisation reports. Therefore, another strategy could be to simply redact that week.\n\nleave_out_last_forecasts_by_reference_date = map(fitted_models_by_report_date) do fitted_model\n    @unpack model_dict, forecast_dates, transformation, inv_transformation,\n        data_to_revise = fitted_model\n    model = GPModel(model_dict)\n\n    forecasts = forecast(model, forecast_dates, n_forecasts; inv_transformation)\n\n    iqr_forecasts = mapreduce(vcat, eachrow(forecasts)) do fc\n        qs = quantile(fc, [0.25, 0.5, 0.75])\n        qs'\n    end\n\n    return (dates = forecast_dates, forecasts = forecasts, iqrs = iqr_forecasts)\nend\n\nThis looks improved but the forecasts have quite large prediction intervals (we have effectively bumped the forecast horizon by one week).\n\nplot_with_forecasts(\n    leave_out_last_forecasts_by_reference_date,\n    \"Forecasts from Different Report Dates (Leave out last week)\";\n    n_ahead = 4,\n    selected_dates = selected_dates\n)\n\n(Image: )","category":"section"},{"location":"vignettes/getting-started/#Approaches-3-5:-Forecasting-with-a-simple-nowcast","page":"Getting Started","title":"Approaches 3-5: Forecasting with a simple nowcast","text":"Now lets consider a really simple nowcasting model. Over recent vintages we notice that the most recent week gets revised significantly but other weeks are fairly stable. Therefore, we fit the ratio of last weeks report to last weeks eventual reported to a LogNormal. The MLE fit for this was LogNormal(logmean = 0.1, logstd = 0.027).\n\nWe generate 100 nowcast samples for the most recent week, across all report dates, by sampling from this distribution and multiplying by the latest reported value for that week.\n\nn_nowcast_samples = 100\n# Simple nowcast on most recent data where we suspect significant revisions\n\nall_nowcast_samples = map(fitted_models_by_report_date) do fitted_model\n    @unpack data_to_revise = fitted_model\n\n    nowcast_samples = [\n        [data_to_revise.revise_values[end] * exp(0.1 + randn() * 0.027)]\n            for _ in 1:n_nowcast_samples\n    ]\nend\n\nWe can use forecast_with_nowcasts to batch 20 forecasts per nowcast signal on top of the inference done in step one.\n\nThis is a very simple nowcasting approach! Note that cached nowcasts from a more sophisticated approach, such as a full generative model defined by e.g. epinowcast or baselinenowcast, could have been deserialized into this approach.\n\nWe compare three variants:\n\nApproach 3 uses the original forecasting method, drawing all forecast samples from the mixture distribution over the weighted particles representing an ensemble of GP models. In this variant we don't enable any HMC steps to refresh the particle ensemble after incorporating the nowcast samples.\nApproach 4 as approach 3, but updates the GP hyperparameters with an HMC refinement step between each nowcast draw (n_hmc=1), which allows the GP particles to adapt to the new data and increases the diversity of the forecast ensemble.\nApproach 5 as approach 3, but interleaves HMC refinement steps between each forecast draw (forecast_n_hmc=1), which increases the diversity of the forecast ensemble by more than Approach 4, but is more computationally expensive.\n\nNote that approach 5 is a mitigation strategy for having a particle ensemble that is too small to capture the posterior distribution over GP hyperparameters, which could lead to underdispersed forecasts. If you have a large enough particle ensemble, approach 4 will be sufficient and equivalent to approach 5.","category":"section"},{"location":"vignettes/getting-started/#Approach-3:-Nowcast-without-HMC-steps","page":"Getting Started","title":"Approach 3: Nowcast without HMC steps","text":"nowcast_no_hmc_forecasts_by_reference_date = map(\n    fitted_models_by_report_date, all_nowcast_samples\n) do fitted_model, nowcast_samples\n    @unpack model_dict, forecast_dates, transformation, inv_transformation,\n        data_to_revise = fitted_model\n    model = GPModel(model_dict)\n\n    nowcasts = create_nowcast_data(\n        nowcast_samples, [data_to_revise.revise_dates[end]];\n        transformation = transformation\n    )\n\n    forecasts = forecast_with_nowcasts(\n        model, nowcasts, forecast_dates, n_forecasts ÷ n_nowcast_samples;\n        inv_transformation\n    )\n\n    iqr_forecasts = mapreduce(vcat, eachrow(forecasts)) do fc\n        qs = quantile(fc, [0.25, 0.5, 0.75])\n        qs'\n    end\n\n    return (dates = forecast_dates, forecasts = forecasts, iqrs = iqr_forecasts)\nend\n\nplot_with_forecasts(\n    nowcast_no_hmc_forecasts_by_reference_date,\n    \"Forecasts from Different Report Dates (Nowcast, no HMC)\";\n    n_ahead = 4,\n    selected_dates = selected_dates\n)\n\n(Image: )","category":"section"},{"location":"vignettes/getting-started/#Approach-4:-Nowcast-with-HMC-step-after-each-nowcast-draw","page":"Getting Started","title":"Approach 4: Nowcast with HMC step after each nowcast draw","text":"Using the same nowcasting setup, we now enable a HMC step for each particle to refresh the GP hyperparameters after incorporating each nowcast sample. Forecasts are then drawn from the refreshed particle ensemble without further HMC steps between forecast draws. This allows the GP hyperparameters to be refined for each nowcast sample, producing a more diverse and better-calibrated forecast ensemble.\n\nnowcast_nc_hmc_forecasts_by_reference_date = map(\n    fitted_models_by_report_date, all_nowcast_samples\n) do fitted_model, nowcast_samples\n    @unpack model_dict, forecast_dates, transformation, inv_transformation,\n        data_to_revise = fitted_model\n    model = GPModel(model_dict)\n\n    nowcasts = create_nowcast_data(\n        nowcast_samples, [data_to_revise.revise_dates[end]];\n        transformation = transformation\n    )\n\n    forecasts = forecast_with_nowcasts(\n        model, nowcasts, forecast_dates, n_forecasts ÷ n_nowcast_samples;\n        inv_transformation, n_hmc = 1, verbose = true\n    )\n\n    iqr_forecasts = mapreduce(vcat, eachrow(forecasts)) do fc\n        qs = quantile(fc, [0.25, 0.5, 0.75])\n        qs'\n    end\n\n    return (dates = forecast_dates, forecasts = forecasts, iqrs = iqr_forecasts)\nend\n\n\nplot_with_forecasts(\n    nowcast_nc_hmc_forecasts_by_reference_date,\n    \"Forecasts from Different Report Dates (Nowcast, with HMC refresh each nowcast)\";\n    n_ahead = 4,\n    selected_dates = selected_dates\n)\n\n(Image: )","category":"section"},{"location":"vignettes/getting-started/#Approach-5:-Nowcast-with-HMC-step-after-each-forecast-draw","page":"Getting Started","title":"Approach 5: Nowcast with HMC step after each forecast draw","text":"We now enable interleaved HMC parameter refinement between forecast draws. This allows the GP hyperparameters to be refined between each forecast sample, which better reflects the posterior distribution over hyperparameters than approach 4, which only refines hyperparameters between nowcast samples. This can lead to a more diverse and better-calibrated forecast ensemble, but is more computationally expensive. Note that if you have a large enough particle ensemble, approach 4 will be sufficient and equivalent to approach 5, as the particle ensemble will already capture the posterior distribution over hyperparameters well enough that further HMC steps between forecast draws won't add much diversity.\n\nnowcast_dr_hmc_forecasts_by_reference_date = map(\n    fitted_models_by_report_date, all_nowcast_samples\n) do fitted_model, nowcast_samples\n    @unpack model_dict, forecast_dates, transformation, inv_transformation,\n        data_to_revise = fitted_model\n    model = GPModel(model_dict)\n\n    nowcasts = create_nowcast_data(\n        nowcast_samples, [data_to_revise.revise_dates[end]];\n        transformation = transformation\n    )\n\n    forecasts = forecast_with_nowcasts(\n        model, nowcasts, forecast_dates, n_forecasts ÷ n_nowcast_samples;\n        inv_transformation, forecast_n_hmc = 1, n_hmc = 0, verbose = true\n    )\n\n    iqr_forecasts = mapreduce(vcat, eachrow(forecasts)) do fc\n        qs = quantile(fc, [0.25, 0.5, 0.75])\n        qs'\n    end\n\n    return (dates = forecast_dates, forecasts = forecasts, iqrs = iqr_forecasts)\nend\n\nplot_with_forecasts(\n    nowcast_dr_hmc_forecasts_by_reference_date,\n    \"Forecasts from Different Report Dates (Nowcast, with HMC refresh each forecast)\";\n    n_ahead = 4,\n    selected_dates = selected_dates\n)\n\n(Image: )","category":"section"},{"location":"vignettes/getting-started/#Scoring","page":"Getting Started","title":"Scoring","text":"To evaluate the quality of our different forecasting approaches, we use the proper scoring rule Continuous Ranked Probability Score (CRPS). A proper scoring rule is a function that assigns a numerical score to a probabilistic forecast, with the property that the score is optimized (in expectation) when the forecast distribution matches the true data distribution.\n\nCRPS is a proper scoring rule that generalizes absolute error, i.e. mean absolute error (MAE), to being a proper score for probabilistic forecasts. For a forecast distribution F(x) = P(X leq x) and observed outcome y, the CRPS score is defined as:\n\ntextCRPS(X y) = mathbbEX - y - frac12mathbbEX_1 - X_2\n\nwhere the first term measures the distance between the forecast ensemble and the observation, and the second term measures the spread of the forecast ensemble.\n\nFor a forecast ensemble X = X_1 X_2 ldots X_n, this can be estimated using an empirical sum.\n\nNote: For production forecasting evaluation, we recommend using the comprehensive scoringutils R package, which provides robust implementations of proper scoring rules, forecast evaluation diagnostics, and visualization tools specifically designed for epidemiological forecasting.\n\nLet's implement a simple CRPS function and functions for getting the mean CRPS score over reporting dates and forecast horizons in order to compare our five forecasting approaches:\n\nfunction crps(y::Real, X::Vector{<:Real})\n    n = length(X)\n\n    # First term: E|X - y|\n    term1 = mean(abs.(X .- y))\n\n    # Second term: E|X_1 - X_2|\n    # Calculate all ordered pairwise differences\n    ordered_pairwise_diffs = [abs(X[i] - X[j]) for i in 1:n for j in (i + 1):n]\n    term2 = mean(ordered_pairwise_diffs)\n\n    # CRPS = E|X - y| - 0.5 * E|X_1 - X_2|\n    return term1 - 0.5 * term2\nend\n\nfunction score_forecast(\n        latestdata, forecast_dates, F; max_horizon = 4, data_transform = x -> x\n    )\n    @assert max_horizon <= length(forecast_dates) \"Not enough data to score full horizon\"\n    score_dates = forecast_dates[1:max_horizon]\n    scorable_data = @filter(latestdata, reference_date in !!score_dates)\n    S = mapreduce(+, scorable_data.confirm[1:max_horizon], eachrow(F.forecasts[1:max_horizon, :])) do y,\n            X\n        crps(data_transform(y), data_transform.(X))\n    end\n    return S / max_horizon\nend\n\nfunction score_all_forecasts(latestdata, forecasts; max_horizon = 4, data_transform = x -> x)\n    total_score = mapreduce(+, forecasts; init = 0.0) do F\n        forecast_dates = F.dates\n        score_forecast(latestdata, forecast_dates, F; max_horizon, data_transform)\n    end\n    return total_score / length(forecasts)\nend\n\nWe can apply the scoring to each forecasting method, leaving out the most recent forecasts (where we don't have all the data to score them).\n\nmost_recent_report_date = maximum(selected_dates)\nlatestdata = @filter(nhsn_vintage_covid_data, report_date == !!most_recent_report_date)\n\nscores = map(\n    [\n        naive_forecasts_by_reference_date,\n        leave_out_last_forecasts_by_reference_date,\n        nowcast_no_hmc_forecasts_by_reference_date,\n        nowcast_nc_hmc_forecasts_by_reference_date,\n        nowcast_dr_hmc_forecasts_by_reference_date\n    ]\n) do F\n    score_all_forecasts(latestdata, F[1:(end - 2)]; data_transform = log)\nend\n\nThen we can plot these scores as score ratios relative to the best approach (nowcast with HMC step per forecast draw).\n\n# Calculate score ratios compared to nowcast with HMC (baseline)\nbaseline_score = scores[end] # nowcast with HMC step per forecast draw is the last in the list\nscore_ratios = [score / baseline_score for score in scores]\n\n# Create bar plot comparing score ratios\nmethod_names = [\"Naive\", \"Leave Out\\nLast\", \"Nowcast\\n(no HMC)\", \"Nowcast\\n(NC HMC)\", \"Nowcast\\n(DR HMC)\"]\n\nfig = Figure(size = (700, 400))\nax = Axis(\n    fig[1, 1],\n    xlabel = \"Forecasting Method\",\n    ylabel = \"Score Ratio\",\n    title = \"Forecast Performance: Score Ratios over approaches (lower is better)\"\n)\n\n# Create bar plot with different colors based on performance\nbar_colors = [ratio > 1.05 ? :red : abs(ratio - 1) < 0.05 ? :green : :blue for ratio in score_ratios]\nbarplot!(\n    ax, 1:5, score_ratios,\n    color = bar_colors,\n    alpha = 0.7,\n    strokewidth = 2,\n    strokecolor = :black\n)\n\n# Add value labels on top of bars\nfor (i, ratio) in enumerate(score_ratios)\n    text!(\n        ax, i, ratio + 0.02, text = string(round(ratio, digits = 2)),\n        align = (:center, :bottom), fontsize = 12\n    )\nend\n\n# Add horizontal line at y=1 for reference (baseline)\nhlines!(ax, [1], color = :black, linestyle = :dash, linewidth = 1)\n\n# Set x-axis labels\nax.xticks = (1:5, method_names)\n\n# Add some padding to y-limits\ny_max = maximum(score_ratios)\nylims!(ax, 0.8, y_max + 0.1)\n\nresize_to_layout!(fig)\nfig\n\n(Image: )","category":"section"},{"location":"vignettes/getting-started/#Results-and-Interpretation","page":"Getting Started","title":"Results and Interpretation","text":"The score ratios clearly show progressive improvement across approaches:\n\nNaive forecasting performs worst - The score ratio shows that naive forecasting is significantly worse than the baseline (ratio > 1), demonstrating that using the most recent reported data without any adjustment for reporting delays leads to systematically poor forecast accuracy. This approach fails to account for the known issue that recent hospitalizations are significantly under-reported.\nLeaving out the last week shows intermediate performance - This approach achieves a score ratio between the naive method and the nowcasting approaches, indicating improved performance over naive forecasting but still worse than nowcasting. While excluding the most recent (and most uncertain) week removes problematic bias due to reporting delay, it effectively increases our forecast horizon by one week, leading to overdispersed predictions.\nBatched forecasts over nowcasts performed best - Batching over nowcast samples significantly improves forecast skill, with the simple nowcast outperforming the naive and leave-out approaches. This demonstrates that even a simple nowcasting model that adjusts for expected revisions in recent data can substantially enhance forecast performance. Increasing the diversity of the forecast ensemble with HMC steps offered marginal improvements, suggesting that while hyperparameter refinement can help, the main gains come from incorporating nowcast adjustments.\n\nThese results support the core motivation for NowcastAutoGP - that combining nowcasting with time series modeling can significantly improve forecast skill in real-world surveillance scenarios where reporting delays are common.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#NowcastAutoGP.jl","page":"Home","title":"NowcastAutoGP.jl","text":"Centers for Disease Control and Prevention • Center for Forecasting and Outbreak Analytics\n\nAutomated Gaussian Process model discovery for time series data with significant on-going revisions","category":"section"},{"location":"#About-NowcastAutoGP.jl","page":"Home","title":"About NowcastAutoGP.jl","text":"NowcastAutoGP.jl is a Julia package for combining nowcasting of epidemiological time series data with forecasting using an ensemble of Gaussian process (GP) models. The package was developed for the CDC Center for Forecasting and Outbreak Analytics (CFA) to support real-time situational awareness and epidemiological forecasting.\n\nThe basic idea behind this package is to use the incremental fitting capabilities of AutoGP.jl to batch forecasts over probababilistic nowcasts of recent data points. In this way, NowcastAutoGP.jl is able to account for the uncertainty in recent data points that are still being revised, while also leveraging the flexibility and scalability of Gaussian processes for forecasting.\n\nThe main upside of this approach is that its flexibility allows us to be agnostic to the nowcasting method used, as long as it can produce generative samples over the distribution of recent data points; noting that point estimate nowcasts can also be used as one-sample degenerate distributions. However, this does mean that:\n\nThe quality of the nowcasts will impact the quality of the forecasts.\nThe nowcasting and forecasting models are not jointly inferred, which may lead to suboptimal performance compared to a fully Bayesian approach in some circumstances; for example, if the nowcasting model is poorly specified.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"# Standard installation\nusing Pkg\nPkg.add(url=\"https://github.com/CDCgov/NowcastAutoGP.jl\")","category":"section"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"Getting started example: A getting started guide demonstrating basic usage for combining forecasting and nowcasting on NHSN covid-19 hospitalization data.","category":"section"},{"location":"#API-Reference-and-Resources","page":"Home","title":"API Reference and Resources","text":"API Documentation","category":"section"}]
}
